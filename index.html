<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="utf-8">
    <title>ROSARY RIDGEBED • 7 Gaben Hügelbeet Pyramide</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdn.jsdelivr.net/npm/three@0.167.1/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.167.1/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.167.1/examples/js/exporters/STLExporter.js"></script>
    <style>
        /* Dein Style bleibt gleich */
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="info">
        /* Dein Info-Div bleibt gleich */
    </div>
    <div id="controls">
        /* Dein Controls-Div bleibt gleich */
    </div>
    <div id="modal">
        /* Dein Modal bleibt gleich */
    </div>
    <script>
        const phi = (1 + Math.sqrt(5)) / 2;
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x001133);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(10,10,15);
        const renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        let isRotating = true;

        const terraces = [];
        const colors = [0x8b4513,0x8b5a2b,0x228b22,0x654321,0x4b3621,0x5d4037,0x228b22];
        const gaben = ["Furcht des Herrn","Frömmigkeit","Erkenntnis","Stärke","Rat","Verstand","Weisheit"];
        let currentR = 9;
        const loader = new THREE.TextureLoader();
        let grass;
        loader.load('https://i.imgur.com/4tZEm8T.jpeg', texture => {
            grass = texture;
            grass.wrapS = grass.wrapT = THREE.RepeatWrapping;
            grass.repeat.set(12,12);
            renderer.render(scene, camera);
        });

        for(let i=0; i<7; i++){
            const h = (i+1)/8 * 16;
            const geo = new THREE.CylinderGeometry(currentR, currentR * phi, 2.5, 64, 1, true);
            const mat = new THREE.MeshPhongMaterial({ color: colors[i], map: i===6 && grass ? grass : null, bumpMap: grass || null, bumpScale: 0.7, shininess: 40 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.y = -8 + h;
            scene.add(mesh);
            terraces.push(mesh);
            currentR /= phi;
        }

        // Goldene Spirale - jetzt als BufferGeometry für dynamische Updates
        const spiralPoints = [];
        let angle = 0;
        let radius = 0.3;
        let y = -8;
        const angleStep = 0.1;
        const maxPoints = 2000; // Pre-allocate
        const spiralGeo = new THREE.BufferGeometry();
        const positions = new Float32Array(maxPoints * 3);
        spiralGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const tubeMat = new THREE.MeshPhongMaterial({color:0xffd700,emissive:0xaa8800,shininess:150});
        const spiral = new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(spiralPoints), 64, 0.25, 16, false), tubeMat);
        scene.add(spiral);

        // Salomonisches Siegel + Pyramide
        /* Bleibt gleich */

        // Lichter
        scene.add(new THREE.AmbientLight(0xffffff, 5));
        const sun = new THREE.DirectionalLight(0xfff8e1, 12);
        sun.position.set(15,40,15);
        scene.add(sun);
        const pointLight = new THREE.PointLight(0xffd700, 10, 100); // Jetzt animierbar
        scene.add(pointLight);
        scene.add(new THREE.HemisphereLight(0x87ceeb, 0x228b22, 6));

        // Modal-Daten und Raycaster bleiben gleich

        // Animation-Verbesserungen
        const clock = new THREE.Clock(); // Für delta time
        let time = 0; // Für sinus-basierte Animationen
        let drawCount = 100; // Für growing spiral

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            time += delta;

            // Rotierende Spirale (verbessert mit Sinus für Puls)
            if(isRotating) {
                spiral.rotation.y += 0.002 + Math.sin(time) * 0.001;
            }

            // Wachsende Spirale: Update points dynamisch
            drawCount = Math.min(drawCount + 1, maxPoints); // Wachstum
            for(let i=0; i<drawCount; i++){
                const posAngle = i * angleStep;
                const posRadius = 0.3 * Math.pow(phi, posAngle / (Math.PI / 2));
                const posY = -8 + posAngle * 0.5 + Math.sin(time + i*0.1) * 0.2; // Leichtes Pulsieren
                positions[i*3] = posRadius * Math.cos(posAngle);
                positions[i*3 + 1] = posY;
                positions[i*3 + 2] = posRadius * Math.sin(posAngle);
            }
            spiral.geometry.attributes.position.needsUpdate = true;
            spiral.geometry.setDrawRange(0, drawCount);

            // Terrassen Pulsieren (Scale-Animation)
            terraces.forEach((terrace, i) => {
                const scale = 1 + Math.sin(time + i) * 0.05; // Leichtes Atmen
                terrace.scale.set(scale, 1, scale); // Horizontal pulsieren
            });

            // Pulsierendes Licht
            pointLight.intensity = 10 + Math.sin(time * 2) * 5;

            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Export, Toggle, Resize bleiben gleich
    </script>
</body>
</html>
